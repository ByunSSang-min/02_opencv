# OpenCV - Day 2

## ğŸ“¡ Image Operations

**Date:** 2025-07-29  
**Author:** Sang-Min Byun

---

<br>

## ğŸ“‹ Project Summary

âš« **Image Operations**

This project demonstrates image **color processing**, binary image generation through **thresholding**, and image **compositing**.

The core idea:
- The image colors are represented using 3 methods: BGR(BGRA), HSV, YUV.
- Generate a binary image through thresholding using Otsu's binarization method to find optimal threshold without iteration.
- Using masking, extract only the subject from a photo with a chroma key background, and then composite it with a photo of a different background.
  - The photo with a chroma key background should be smaller than the other photo that be composited.


<br>

## ğŸŸ¥ Representing the image colors

### ğŸ“· Python Code (color.py)

This code displays the image in three formats: the original format, BGR format, and BGRA format.

```python
import cv2
import numpy as np

# ê¸°ë³¸ê°’
img = cv2.imread('../img/like_lenna.png')

# bgr
bgr = cv2.imread('../img/like_lenna.png', cv2.IMREAD_COLOR)

# a
bgra = cv2.imread('../img/like_lenna.png', cv2.IMREAD_UNCHANGED)

# shape
print("default", img.shape, "color", bgr.shape, "unchanged", bgra.shape)

# ì´ë¯¸ì§€ ë³´ì—¬ì£¼ê¸°
cv2.imshow('img', img)
cv2.imshow('bgr', bgr)
cv2.imshow('alpha', bgra[:,:,3])

cv2.waitKey(0)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/color_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (bgr2gray.py)

This code displays the image in three format: the original format, gray format 1, gray format 2.  
Gray format 1 image is generated by method using average value.  
Gray format 2 image is generated by method using cv2.cvtcolor(img, flag) function.

```python
import cv2
import numpy as np

img = cv2.imread('../img/like_lenna.png')

img2 = img.astype(np.uint16)                # dtype ë³€ê²½ ---â‘ 
b,g,r = cv2.split(img2)                     # ì±„ë„ ë³„ë¡œ ë¶„ë¦¬ ---â‘¡
#b,g,r = img2[:,:,0], img2[:,:,1], img2[:,:,2]
gray1 = ((b + g + r)/3).astype(np.uint8)    # í‰ê·  ê°’ ì—°ì‚°í›„ dtype ë³€ê²½ ---â‘¢

gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # BGRì„ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ë³€ê²½ ---â‘£
cv2.imshow('original', img)
cv2.imshow('gray1', gray1)
cv2.imshow('gray2', gray2)

cv2.waitKey(0)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2gray_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (bgr2hsv.py, bgr2yuv.py)

These codes display the image in RGB color system.  
The two codes convert the BGR format into the HSV and YUV formats, respectively.

```python
# BGR ê°’ì„ HSVë¡œ ë³€í™˜

import cv2
import numpy as np

#---â‘  BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ì›ìƒ‰ í”½ì…€ ìƒì„±
red_bgr = np.array([[[0,0,255]]], dtype=np.uint8)   # ë¹¨ê°• ê°’ë§Œ ê°–ëŠ” í”½ì…€
green_bgr = np.array([[[0,255,0]]], dtype=np.uint8) # ì´ˆë¡ ê°’ë§Œ ê°–ëŠ” í”½ì…€
blue_bgr = np.array([[[255,0,0]]], dtype=np.uint8)  # íŒŒë‘ ê°’ë§Œ ê°–ëŠ” í”½ì…€
yellow_bgr = np.array([[[0,255,255]]], dtype=np.uint8) # ë…¸ë‘ ê°’ë§Œ ê°–ëŠ” í”½ì…€

#---â‘¡ BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¥¼ HSV ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
red_hsv = cv2.cvtColor(red_bgr, cv2.COLOR_BGR2HSV);
green_hsv = cv2.cvtColor(green_bgr, cv2.COLOR_BGR2HSV);
blue_hsv = cv2.cvtColor(blue_bgr, cv2.COLOR_BGR2HSV);
yellow_hsv = cv2.cvtColor(yellow_bgr, cv2.COLOR_BGR2HSV);

#---â‘¢ HSVë¡œ ë³€í™˜í•œ í”½ì…€ ì¶œë ¥
print("red:",red_hsv)
print("green:", green_hsv)
print("blue", blue_hsv)
print("yellow", yellow_hsv)

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2hsv_py_result.jpg)
<br>

---

<br>

```python
# BGR ê°’ì„ YUVë¡œ ë³€í™˜

import cv2
import numpy as np

#---â‘  BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ 3ê°€ì§€ ë°ê¸°ì˜ í”½ì…€ ìƒì„±
dark = np.array([[[0,0,0]]], dtype=np.uint8)        # 3 ì±„ë„ ëª¨ë‘ 0ì¸ ê°€ì¥ ì–´ë‘ìš´ í”½ì…€
middle = np.array([[[127,127,127]]], dtype=np.uint8) # 3 ì±„ë„ ëª¨ë‘ 127ì¸ ì¤‘ê°„ ë°ê¸° í”½ì…€
bright = np.array([[[255,255,255]]], dtype=np.uint8) # 3 ì±„ë„ ëª¨ë‘ 255ì¸ ê°€ì¥ ë°ì€ í”½ì…€

#---â‘¡ BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¥¼ YUV ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
dark_yuv = cv2.cvtColor(dark, cv2.COLOR_BGR2YUV)
middle_yuv = cv2.cvtColor(middle, cv2.COLOR_BGR2YUV)
bright_yuv = cv2.cvtColor(bright, cv2.COLOR_BGR2YUV)

#---â‘¢ YUVë¡œ ë³€í™˜í•œ í”½ì…€ ì¶œë ¥
print("dark:",dark_yuv)
print("middle:", middle_yuv)
print("bright", bright_yuv)

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2yuv_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (threshold.py)

Global thresholding is a method where a certain threshold is set, and pixel values are assigned 255 if they exceed the threshold, or 0 if they do not.  
The code below displays the process activating global thresholding through numpy and cv2.threshold().

```python
import cv2
import numpy as np
import matplotlib.pylab as plt

# ì´ë¯¸ì§€ë¥¼ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ì½ê¸°
img = cv2.imread('../img/like_lenna.png', cv2.IMREAD_GRAYSCALE)

# NumPy APIë¡œ ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ ë§Œë“¤ê¸°
thresh_np = np.zeros_like(img)   # ì›ë³¸ê³¼ ë™ì¼í•œ í¬ê¸°ì˜ 0ìœ¼ë¡œ ì±„ì›Œì§„ ì´ë¯¸ì§€
thresh_np[ img > 127] = 255      # 127 ë³´ë‹¤ í° ê°’ë§Œ 255ë¡œ ë³€ê²½

# OpenCV APIë¡œ ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ ë§Œë“¤ê¸°
ret, thresh_cv = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
# ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ì— ì‚¬ìš©ëœ ë¬¸í„± ê°’ ë°˜í™˜
print(ret)

# ì›ë³¸ê³¼ ê²°ê³¼ë¬¼ì„ matplotlibìœ¼ë¡œ ì¶œë ¥
imgs = {'Original': img, 'NumPy API':thresh_np, 'cv2.threshold': thresh_cv}
for i , (key, value) in enumerate(imgs.items()):
    plt.subplot(1, 3, i+1)
    plt.title(key)
    plt.imshow(value, cmap='gray')
    plt.xticks([]); plt.yticks([])

plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/threshold_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (threshold_otsu.py)

This code finds optimal threshold using Otsu's binarization method.

```python
import cv2
import numpy as np
import matplotlib.pylab as plt


# ì´ë¯¸ì§€ë¥¼ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ì½ê¸°
img = cv2.imread('../img/like_lenna.png', cv2.IMREAD_GRAYSCALE)

# ê²½ê³„ê°’ì„ 130ìœ¼ë¡œ ì§€ì •
_, t_130 = cv2.threshold(img, 130, 255, cv2.THRESH_BINARY)

# ê²½ê³„ê°’ì„ ì§€ì •í•˜ì§€ ì•Šê³  OTSU ì•Œê³ ë¦¬ì¦˜ ì„ íƒ
t, t_otsu = cv2.threshold(img, -1, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

# OTSU ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì„ íƒëœ ê²½ê³„ê°’ ì¶œë ¥
print('otsu threshold:', t)

imgs = {'Original': img, 't:130':t_130, 'otsu:%d'%t: t_otsu}
for i , (key, value) in enumerate(imgs.items()):
    plt.subplot(1, 3, i+1)
    plt.title(key)
    plt.imshow(value, cmap='gray')
    plt.xticks([]); plt.yticks([])

plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/threshold_otsu_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (threshold_adapted.py)

Adaptive thresholding is a method finds optimal threshold using pixel values around divided image.  
The code below shows how to use adaptive thresholding.

```python
import cv2
import numpy as np 
import matplotlib.pyplot as plt 

blk_size = 9        # ë¸”ëŸ­ ì‚¬ì´ì¦ˆ
C = 5               # ì°¨ê° ìƒìˆ˜ 
img = cv2.imread('../img/like_lenna.png', cv2.IMREAD_GRAYSCALE) # ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ  ì½ê¸°

# ---â‘  ì˜¤ì¸ ì˜ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë‹¨ì¼ ê²½ê³„ ê°’ì„ ì „ì²´ ì´ë¯¸ì§€ì— ì ìš©
ret, th1 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

# ---â‘¡ ì–´ëí‹°ë“œ ì“°ë ˆì‹œí™€ë“œë¥¼ í‰ê· ê³¼ ê°€ìš°ì‹œì•ˆ ë¶„í¬ë¡œ ê°ê° ì ìš©
th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,\
                                      cv2.THRESH_BINARY, blk_size, C)
th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \
                                     cv2.THRESH_BINARY, blk_size, C)

# ---â‘¢ ê²°ê³¼ë¥¼ Matplotìœ¼ë¡œ ì¶œë ¥
imgs = {'Original': img, 'Global-Otsu:%d'%ret:th1, \
        'Adapted-Mean':th2, 'Adapted-Gaussian': th3}
for i, (k, v) in enumerate(imgs.items()):
    plt.subplot(2,2,i+1)
    plt.title(k)
    plt.imshow(v,'gray')
    plt.xticks([]),plt.yticks([])

plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/threshold_adapted_py_result.jpg)
<br>

---

### ğŸ“· Python Code (threshold_adapted.py, project01.py)

Chroma key is a masking method using colors. (Usually green)  
This code composites a picture with green background to other picture with different background.

```python
import cv2
import numpy as np
import matplotlib.pylab as plt

#--â‘  í¬ë¡œë§ˆí‚¤ ë°°ê²½ ì˜ìƒê³¼ í•©ì„±í•  ë°°ê²½ ì˜ìƒ ì½ê¸°
img1 = cv2.imread('../img/man_chromakey.jpg')
img2 = cv2.imread('../img/like_lenna.png')

#--â‘¡ ROI ì„ íƒì„ ìœ„í•œ ì¢Œí‘œ ê³„ì‚°
height1, width1 = img1.shape[:2]
height2, width2 = img2.shape[:2]
x = (width2 - width1)//2
y = height2 - height1
w = x + width1
h = y + height1

#--â‘¢ í¬ë¡œë§ˆí‚¤ ë°°ê²½ ì˜ìƒì—ì„œ í¬ë¡œë§ˆí‚¤ ì˜ì—­ì„ 10í”½ì…€ ì •ë„ë¡œ ì§€ì •
chromakey = img1[:10, :10, :]
offset = 20

#--â‘£ í¬ë¡œë§ˆí‚¤ ì˜ì—­ê³¼ ì˜ìƒ ì „ì²´ë¥¼ HSVë¡œ ë³€ê²½
hsv_chroma = cv2.cvtColor(chromakey, cv2.COLOR_BGR2HSV)
hsv_img = cv2.cvtColor(img1, cv2.COLOR_BGR2HSV)

#--â‘¤ í¬ë¡œë§ˆí‚¤ ì˜ì—­ì˜ Hê°’ì—ì„œ offset ë§Œí¼ ì—¬ìœ ë¥¼ ë‘ì–´ì„œ ë²”ìœ„ ì§€ì •
# offset ê°’ì€ ì—¬ëŸ¬ì°¨ë¡€ ì‹œë„ í›„ ê²°ì •
#chroma_h = hsv_chroma[0]
chroma_h = hsv_chroma[:,:,0]
lower = np.array([chroma_h.min()-offset, 100, 100])
upper = np.array([chroma_h.max()+offset, 255, 255])

#--â‘¥ ë§ˆìŠ¤í¬ ìƒì„± ë° ë§ˆìŠ¤í‚¹ í›„ í•©ì„±
mask = cv2.inRange(hsv_img, lower, upper)
mask_inv = cv2.bitwise_not(mask)
roi = img2[y:h, x:w]
fg = cv2.bitwise_and(img1, img1, mask=mask_inv)
bg = cv2.bitwise_and(roi, roi, mask=mask)
img2[y:h, x:w] = fg + bg

#--â‘¦ ê²°ê³¼ ì¶œë ¥
cv2.imshow('chromakey', img1)
cv2.imshow('added', img2)
cv2.waitKey()
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/chromakey_py_result.jpg)
<br>

---

```python
# í¬ë¡œë§ˆí‚¤ ë°©ì‹ì„ ì‘ìš©í•œ project01

import cv2
import numpy as np
import matplotlib.pylab as plt

# í¬ë¡œë§ˆí‚¤ ë°°ê²½ ì‚¬ì§„ê³¼ í•©ì„±í•  ë°°ê²½ ì‚¬ì§„ ì½ê¸°
img1 = cv2.imread('../img/man_crying.png')
img2 = cv2.imread('../img/mbape_smiling.jpg')

# ì¢Œí‘œ ê³„ì‚°
height1, width1 = img1.shape[:2]
height2, width2 = img2.shape[:2]

# ì¤‘ì•™ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì‚´ì§ ì´ë™
x = (width2 - width1)//5
y = height2 - height1
w = x + width1
h = y + height1

# í¬ë¡œë§ˆí‚¤ ë°°ê²½ ì˜ìƒì—ì„œ í¬ë¡œë§ˆí‚¤ ì˜ì—­ì„ 10í”½ì…€ ì •ë„ë¡œ ì§€ì •
chromakey = img1[:10, :10, :]
offset = 20

# í¬ë¡œë§ˆí‚¤ ì˜ì—­ê³¼ ì˜ìƒ ì „ì²´ë¥¼ HSVë¡œ ë³€ê²½
hsv_chroma = cv2.cvtColor(chromakey, cv2.COLOR_BGR2HSV)
hsv_img = cv2.cvtColor(img1, cv2.COLOR_BGR2HSV)

# í¬ë¡œë§ˆí‚¤ ì˜ì—­ì˜ Hê°’ì—ì„œ offset ë§Œí¼ ì—¬ìœ ë¥¼ ë‘ì–´ì„œ ë²”ìœ„ ì§€ì •
# offset ê°’ì€ ì—¬ëŸ¬ì°¨ë¡€ ì‹œë„ í›„ ê²°ì •
# chroma_h = hsv_chroma[0]
chroma_h = hsv_chroma[:,:,0]
lower = np.array([chroma_h.min()-offset, 100, 100])
upper = np.array([chroma_h.max()+offset, 255, 255])

# ë§ˆìŠ¤í¬ ìƒì„± ë° ë§ˆìŠ¤í‚¹ í›„ í•©ì„±
mask = cv2.inRange(hsv_img, lower, upper)
mask_inv = cv2.bitwise_not(mask)
roi = img2[y:h, x:w]
fg = cv2.bitwise_and(img1, img1, mask=mask_inv)
bg = cv2.bitwise_and(roi, roi, mask=mask)
img2[y:h, x:w] = fg + bg

# ê²°ê³¼ ì¶œë ¥
cv2.imshow('finished', img2)

# ì´ë¯¸ì§€ ì €ì¥
cv2.imwrite('../img/finished.jpg', img2)

# ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆëŠ”ì§€ í™•ì¸
if cv2.imwrite('../img/finished.jpg', img2):
    print("ì´ë¯¸ì§€ ì €ì¥ ì„±ê³µ!")
else:
    print("ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨!")

cv2.waitKey()
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/project01_py_result.jpg)
<br>

---

## ğŸ“¡ ROI, Histogram (Normalize, Equalization) and CLAHE

---

<br>

## ğŸ“‹ Project Summary

âš« **ROI, Histogram (Normalize, Equalization) and CLAHE**

This project demonstrates image's **ROI (Region Of Interest)**, displaying process using **Normalize**, **Equalization** and **CLAHE** through **Histogram**.

The core idea:
- ROI
- Histogram
- Normalize
- Equalizaion
- CLAHE


<br>

## ğŸŸ¦ ROI

### ğŸ“· python code (roi.py, roi_copy.py)

These codes display roi of images as green rectangular.

```python
# ê´€ì‹¬ì˜ì—­ í‘œì‹œ (roi.py)

import cv2
import numpy as np

img = cv2.imread('../img/mbape_smiling.jpg')

x=140; y=30; w=350; h=380       # roi ì¢Œí‘œ
roi = img[y:y+h, x:x+w]         # roi ì§€ì •        ---â‘ 

print(roi.shape)
cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0))
cv2.imshow("img", img)

# ì´ë¯¸ì§€ ì €ì¥
cv2.imwrite('../img/finished_emphasizing.jpg', img)

key = cv2.waitKey(0)
print(key)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/roi_py_result.jpg)
<br>

---

```python
# ê´€ì‹¬ì˜ì—­ ë³µì œ ë° ìƒˆ ì°½ì— ë„ìš°ê¸° (roi_copy.py)

import cv2
import numpy as np

img = cv2.imread('../img/mbape_smiling.jpg')

x=140; y=30; w=350; h=380       # roi ì¢Œí‘œ
roi = img[y:y+h, x:x+w]         # roi ì§€ì •        ---â‘ 

print(roi.shape)
cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0))
img2 = roi.copy()           # roi ë°°ì—´ ë³µì œ ---â‘ 

cv2.imshow("img", img)      # ì›ë³¸ ì´ë¯¸ì§€ ì¶œë ¥
cv2.imshow("roi", img2)     # roi ë§Œ ë”°ë¡œ ì¶œë ¥

# ì´ë¯¸ì§€ ì €ì¥
cv2.imwrite('../img/finished_emphasizing.jpg', img)
cv2.imwrite('../img/emphasized_part.jpg', img2)

cv2.waitKey(0)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/roi_copy_py_result.jpg)
<br>

---

### ğŸ“· python code (roi_crop_mouse.py)

This code sets roi of images by using mouse.  
The roi is represented by red rectangular.

```python
# ë§ˆìš°ìŠ¤ë¡œ ê´€ì‹¬ì˜ì—­ ì§€ì • ë° í‘œì‹œ, ì €ì¥

import cv2
import numpy as np

isDragging = False                      # ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ìƒíƒœ ì €ì¥ 
x0, y0, w, h = -1,-1,-1,-1              # ì˜ì—­ ì„ íƒ ì¢Œí‘œ ì €ì¥
blue, red = (255,0,0),(0,0,255)         # ìƒ‰ìƒ ê°’ 

def onMouse(event,x,y,flags,param):     # ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ í•¨ìˆ˜
    global isDragging, x0, y0, img      # ì „ì—­ë³€ìˆ˜ ì°¸ì¡°
    if event == cv2.EVENT_LBUTTONDOWN:  # ì™¼ìª½ ë§ˆìš°ìŠ¤ ë²„íŠ¼ ë‹¤ìš´, ë“œë˜ê·¸ ì‹œì‘
        isDragging = True
        x0 = x
        y0 = y
    elif event == cv2.EVENT_MOUSEMOVE:  # ë§ˆìš°ìŠ¤ ì›€ì§ì„
        if isDragging:                  # ë“œë˜ê·¸ ì§„í–‰ ì¤‘
            img_draw = img.copy()       # ì‚¬ê°í˜• ê·¸ë¦¼ í‘œí˜„ì„ ìœ„í•œ ì´ë¯¸ì§€ ë³µì œ
            cv2.rectangle(img_draw, (x0, y0), (x, y), blue, 2) # ë“œë˜ê·¸ ì§„í–‰ ì˜ì—­ í‘œì‹œ
            cv2.imshow('img', img_draw) # ì‚¬ê°í˜• í‘œì‹œëœ ê·¸ë¦¼ í™”ë©´ ì¶œë ¥
    elif event == cv2.EVENT_LBUTTONUP:  # ì™¼ìª½ ë§ˆìš°ìŠ¤ ë²„íŠ¼ ì—…
        if isDragging:                  # ë“œë˜ê·¸ ì¤‘ì§€
            isDragging = False          
            w = x - x0                  # ë“œë˜ê·¸ ì˜ì—­ í­ ê³„ì‚°
            h = y - y0                  # ë“œë˜ê·¸ ì˜ì—­ ë†’ì´ ê³„ì‚°
            print("x:%d, y:%d, w:%d, h:%d" % (x0, y0, w, h))
            if w > 0 and h > 0:         # í­ê³¼ ë†’ì´ê°€ ì–‘ìˆ˜ì´ë©´ ë“œë˜ê·¸ ë°©í–¥ì´ ì˜³ìŒ
                img_draw = img.copy()   # ì„ íƒ ì˜ì—­ì— ì‚¬ê°í˜• ê·¸ë¦¼ì„ í‘œì‹œí•  ì´ë¯¸ì§€ ë³µì œ
                # ì„ íƒ ì˜ì—­ì— ë¹¨ê°„ ì‚¬ê°í˜• í‘œì‹œ
                cv2.rectangle(img_draw, (x0, y0), (x, y), red, 2) 
                cv2.imshow('img', img_draw) # ë¹¨ê°„ ì‚¬ê°í˜• ê·¸ë ¤ì§„ ì´ë¯¸ì§€ í™”ë©´ ì¶œë ¥
                roi = img[y0:y0+h, x0:x0+w] # ì›ë³¸ ì´ë¯¸ì§€ì—ì„œ ì„ íƒ ì˜ì˜ë§Œ ROIë¡œ ì§€ì •
                cv2.imshow('cropped', roi)  # ROI ì§€ì • ì˜ì—­ì„ ìƒˆì°½ìœ¼ë¡œ í‘œì‹œ
                cv2.moveWindow('cropped', 0, 0) # ìƒˆì°½ì„ í™”ë©´ ì¢Œì¸¡ ìƒë‹¨ì— ì´ë™
                cv2.imwrite('../img/cropped.jpg', roi)   # ROI ì˜ì—­ë§Œ íŒŒì¼ë¡œ ì €ì¥
                cv2.imwrite('../img/drawn_img.jpg', img_draw) # ë¹¨ê°„ ì‚¬ê°í˜• ê·¸ë ¤ì§„ ì´ë¯¸ì§€ íŒŒì¼ë¡œ ì €ì¥
                print("croped.")
            else:
                cv2.imshow('img', img)  # ë“œë˜ê·¸ ë°©í–¥ì´ ì˜ëª»ëœ ê²½ìš° ì‚¬ê°í˜• ê·¸ë¦¼ã…‡ã…£ ì—†ëŠ” ì›ë³¸ ì´ë¯¸ì§€ ì¶œë ¥
                print("ì¢Œì¸¡ ìƒë‹¨ì—ì„œ ìš°ì¸¡ í•˜ë‹¨ìœ¼ë¡œ ì˜ì—­ì„ ë“œë˜ê·¸ í•˜ì„¸ìš”.")

img = cv2.imread('../img/mbape_smiling.jpg')

cv2.imshow('img', img)
cv2.setMouseCallback('img', onMouse) # ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë“±ë¡ ---â‘§
cv2.waitKey()
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/roi_mouse_py_result.jpg)
<br>

---

<br>

## ğŸŸ© Histogram (Normalize, Equalization) and CLAHE

### ğŸ“· python code (histo_rgb.py)

This code displays the elements of images by histogram.

```python
import cv2
import numpy as np
import matplotlib.pylab as plt

#--â‘  ì´ë¯¸ì§€ ì½ê¸° ë° ì¶œë ¥
img = cv2.imread('../img/mbape_smiling.jpg')
cv2.imshow('img', img)

#--â‘¡ íˆìŠ¤í† ê·¸ë¨ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
channels = cv2.split(img)
colors = ('b', 'g', 'r')
for (ch, color) in zip (channels, colors):
    hist = cv2.calcHist([ch], [0], None, [256], [0, 256])
    plt.plot(hist, color = color)
plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/histo_rgb_py_result.jpg)
<br>

---

### ğŸ“· python code (histo_nomalization.py)

This code changes the light intensity of gray images effectively. 

```python
# íˆìŠ¤í† ê·¸ë¨ ì •ê·œí™”

import cv2
import numpy as np
import matplotlib.pylab as plt

#--â‘  ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ì˜ìƒ ì½ê¸°
img = cv2.imread('../img/lumiere.jpg', cv2.IMREAD_GRAYSCALE)

#--â‘¡ ì§ì ‘ ì—°ì‚°í•œ ì •ê·œí™”
img_f = img.astype(np.float32)
img_norm = ((img_f - img_f.min()) * (255) / (img_f.max() - img_f.min()))
img_norm = img_norm.astype(np.uint8)

#--â‘¢ OpenCV APIë¥¼ ì´ìš©í•œ ì •ê·œí™”
img_norm2 = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX)

#--â‘£ íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
hist = cv2.calcHist([img], [0], None, [256], [0, 255])
hist_norm = cv2.calcHist([img_norm], [0], None, [256], [0, 255])
hist_norm2 = cv2.calcHist([img_norm2], [0], None, [256], [0, 255])

cv2.imshow('Before', img)
cv2.imshow('Manual', img_norm)
cv2.imshow('cv2.normalize()', img_norm2)

hists = {'Before' : hist, 'Manual':hist_norm, 'cv2.normalize()':hist_norm2}
for i, (k, v) in enumerate(hists.items()):
    plt.subplot(1,3,i+1)
    plt.title(k)
    plt.plot(v)
plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/normalize_result.jpg)
<br>

---

## ğŸ“¦ Requirements

* Python
  - opencv
  - numpy
  - matplotlib
