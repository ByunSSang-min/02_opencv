# OpenCV - Day 2

## ğŸ“¡ Image Operations

**Date:** 2025-07-29  
**Author:** Sang-Min Byun

---

<br>

## ğŸ“‹ Project Summary

âš« **Image Operations**

This project demonstrates image **color processing**, binary image generation through **thresholding**, and image **compositing**.

The core idea:
- The image colors are represented using 3 methods: BGR(BGRA), HSV, YUV.
- Generate a binary image through thresholding using Otsu's binarization method to find optimal threshold without iteration.
- Using masking, extract only the subject from a photo with a chroma key background, and then composite it with a photo of a different background.
  - The photo with a chroma key background should be smaller than the other photo that be composited.


<br>

## ğŸŸ¥ Representing the image colors

### ğŸ“· Python Code (color.py)

This code displays the image in three formats: the original format, BGR format, and BGRA format.

```python
import cv2
import numpy as np

# ê¸°ë³¸ê°’
img = cv2.imread('../img/like_lenna.png')

# bgr
bgr = cv2.imread('../img/like_lenna.png', cv2.IMREAD_COLOR)

# a
bgra = cv2.imread('../img/like_lenna.png', cv2.IMREAD_UNCHANGED)

# shape
print("default", img.shape, "color", bgr.shape, "unchanged", bgra.shape)

# ì´ë¯¸ì§€ ë³´ì—¬ì£¼ê¸°
cv2.imshow('img', img)
cv2.imshow('bgr', bgr)
cv2.imshow('alpha', bgra[:,:,3])

cv2.waitKey(0)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/color_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (bgr2gray.py)

This code displays the image in three format: the original format, gray format 1, gray format 2.  
Gray format 1 image is generated by method using average value.  
Gray format 2 image is generated by method using cv2.cvtcolor(img, flag) function.

```python
import cv2
import numpy as np

img = cv2.imread('../img/like_lenna.png')

img2 = img.astype(np.uint16)                # dtype ë³€ê²½ ---â‘ 
b,g,r = cv2.split(img2)                     # ì±„ë„ ë³„ë¡œ ë¶„ë¦¬ ---â‘¡
#b,g,r = img2[:,:,0], img2[:,:,1], img2[:,:,2]
gray1 = ((b + g + r)/3).astype(np.uint8)    # í‰ê·  ê°’ ì—°ì‚°í›„ dtype ë³€ê²½ ---â‘¢

gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # BGRì„ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ë³€ê²½ ---â‘£
cv2.imshow('original', img)
cv2.imshow('gray1', gray1)
cv2.imshow('gray2', gray2)

cv2.waitKey(0)
cv2.destroyAllWindows()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2gray_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (bgr2hsv.py, bgr2yuv.py)

These codes display the image in RGB color system.  
The two codes convert the BGR format into the HSV and YUV formats, respectively.

```python
# BGR ê°’ì„ HSVë¡œ ë³€í™˜

import cv2
import numpy as np

#---â‘  BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ì›ìƒ‰ í”½ì…€ ìƒì„±
red_bgr = np.array([[[0,0,255]]], dtype=np.uint8)   # ë¹¨ê°• ê°’ë§Œ ê°–ëŠ” í”½ì…€
green_bgr = np.array([[[0,255,0]]], dtype=np.uint8) # ì´ˆë¡ ê°’ë§Œ ê°–ëŠ” í”½ì…€
blue_bgr = np.array([[[255,0,0]]], dtype=np.uint8)  # íŒŒë‘ ê°’ë§Œ ê°–ëŠ” í”½ì…€
yellow_bgr = np.array([[[0,255,255]]], dtype=np.uint8) # ë…¸ë‘ ê°’ë§Œ ê°–ëŠ” í”½ì…€

#---â‘¡ BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¥¼ HSV ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
red_hsv = cv2.cvtColor(red_bgr, cv2.COLOR_BGR2HSV);
green_hsv = cv2.cvtColor(green_bgr, cv2.COLOR_BGR2HSV);
blue_hsv = cv2.cvtColor(blue_bgr, cv2.COLOR_BGR2HSV);
yellow_hsv = cv2.cvtColor(yellow_bgr, cv2.COLOR_BGR2HSV);

#---â‘¢ HSVë¡œ ë³€í™˜í•œ í”½ì…€ ì¶œë ¥
print("red:",red_hsv)
print("green:", green_hsv)
print("blue", blue_hsv)
print("yellow", yellow_hsv)

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2hsv_py_result.jpg)
<br>

---

<br>

```python
# BGR ê°’ì„ YUVë¡œ ë³€í™˜

import cv2
import numpy as np

#---â‘  BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ 3ê°€ì§€ ë°ê¸°ì˜ í”½ì…€ ìƒì„±
dark = np.array([[[0,0,0]]], dtype=np.uint8)        # 3 ì±„ë„ ëª¨ë‘ 0ì¸ ê°€ì¥ ì–´ë‘ìš´ í”½ì…€
middle = np.array([[[127,127,127]]], dtype=np.uint8) # 3 ì±„ë„ ëª¨ë‘ 127ì¸ ì¤‘ê°„ ë°ê¸° í”½ì…€
bright = np.array([[[255,255,255]]], dtype=np.uint8) # 3 ì±„ë„ ëª¨ë‘ 255ì¸ ê°€ì¥ ë°ì€ í”½ì…€

#---â‘¡ BGR ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¥¼ YUV ì»¬ëŸ¬ ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜
dark_yuv = cv2.cvtColor(dark, cv2.COLOR_BGR2YUV)
middle_yuv = cv2.cvtColor(middle, cv2.COLOR_BGR2YUV)
bright_yuv = cv2.cvtColor(bright, cv2.COLOR_BGR2YUV)

#---â‘¢ YUVë¡œ ë³€í™˜í•œ í”½ì…€ ì¶œë ¥
print("dark:",dark_yuv)
print("middle:", middle_yuv)
print("bright", bright_yuv)

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/bgr2yuv_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (threshold.py)

Global thresholding is a method where a certain threshold is set, and pixel values are assigned 255 if they exceed the threshold, or 0 if they do not.  
The code below displays the process activating global thresholding through numpy and cv2.threshold().

```python
import cv2
import numpy as np
import matplotlib.pylab as plt

# ì´ë¯¸ì§€ë¥¼ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ì½ê¸°
img = cv2.imread('../img/like_lenna.png', cv2.IMREAD_GRAYSCALE)

# NumPy APIë¡œ ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ ë§Œë“¤ê¸°
thresh_np = np.zeros_like(img)   # ì›ë³¸ê³¼ ë™ì¼í•œ í¬ê¸°ì˜ 0ìœ¼ë¡œ ì±„ì›Œì§„ ì´ë¯¸ì§€
thresh_np[ img > 127] = 255      # 127 ë³´ë‹¤ í° ê°’ë§Œ 255ë¡œ ë³€ê²½

# OpenCV APIë¡œ ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ ë§Œë“¤ê¸°
ret, thresh_cv = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
# ë°”ì´ë„ˆë¦¬ ì´ë¯¸ì§€ì— ì‚¬ìš©ëœ ë¬¸í„± ê°’ ë°˜í™˜
print(ret)

# ì›ë³¸ê³¼ ê²°ê³¼ë¬¼ì„ matplotlibìœ¼ë¡œ ì¶œë ¥
imgs = {'Original': img, 'NumPy API':thresh_np, 'cv2.threshold': thresh_cv}
for i , (key, value) in enumerate(imgs.items()):
    plt.subplot(1, 3, i+1)
    plt.title(key)
    plt.imshow(value, cmap='gray')
    plt.xticks([]); plt.yticks([])

plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/threshold_py_result.jpg)
<br>

---

<br>

### ğŸ“· Python Code (threshold_otsu.py)

This code finds optimal threshold using Otsu's binarization method.

```python
import cv2
import numpy as np
import matplotlib.pylab as plt


# ì´ë¯¸ì§€ë¥¼ ê·¸ë ˆì´ ìŠ¤ì¼€ì¼ë¡œ ì½ê¸°
img = cv2.imread('../img/like_lenna.png', cv2.IMREAD_GRAYSCALE)

# ê²½ê³„ê°’ì„ 130ìœ¼ë¡œ ì§€ì •
_, t_130 = cv2.threshold(img, 130, 255, cv2.THRESH_BINARY)

# ê²½ê³„ê°’ì„ ì§€ì •í•˜ì§€ ì•Šê³  OTSU ì•Œê³ ë¦¬ì¦˜ ì„ íƒ
t, t_otsu = cv2.threshold(img, -1, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)

# OTSU ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì„ íƒëœ ê²½ê³„ê°’ ì¶œë ¥
print('otsu threshold:', t)

imgs = {'Original': img, 't:130':t_130, 'otsu:%d'%t: t_otsu}
for i , (key, value) in enumerate(imgs.items()):
    plt.subplot(1, 3, i+1)
    plt.title(key)
    plt.imshow(value, cmap='gray')
    plt.xticks([]); plt.yticks([])

plt.show()

```

### ğŸ“· **Result Screenshot:**

![Result](result_screenshot/threshold_otsu_py_result.jpg)
<br>

---

<br>
